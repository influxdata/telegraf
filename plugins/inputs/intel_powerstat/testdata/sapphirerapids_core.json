{
  "Header": {
    "Copyright": "Copyright (c) 2001 - 2023 Intel Corporation. All rights reserved.",
    "Info": "Performance Monitoring Events for 4th Generation Intel(R) Xeon(R) Processor Scalable Family based on Sapphire Rapids microarchitecture - V1.15",
    "DatePublished": "06/28/2023",
    "Version": "1.15",
    "Legend": ""
  },
  "Events": [
    {
      "EventCode": "0x00",
      "UMask": "0x02",
      "EventName": "CPU_CLK_UNHALTED.THREAD",
      "BriefDescription": "Core cycles when the thread is not in halt state",
      "PublicDescription": "Counts the number of core cycles while the thread is not in a halt state. The thread enters the halt state when it is running the HLT instruction. This event is a component in many key event ratios. The core frequency may change from time to time due to transitions associated with Enhanced Intel SpeedStep Technology or TM2. For this reason this event may have a changing ratio with regards to time. When the core frequency is constant, this event can approximate elapsed time while the core was not in the halt state. It is counted on a dedicated fixed counter, leaving the eight programmable counters available for other events.",
      "Counter": "Fixed counter 1",
      "PEBScounters": "33",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0x00",
      "UMask": "0x03",
      "EventName": "CPU_CLK_UNHALTED.REF_TSC",
      "BriefDescription": "Reference cycles when the core is not in halt state.",
      "PublicDescription": "Counts the number of reference cycles when the core is not in a halt state. The core enters the halt state when it is running the HLT instruction or the MWAIT instruction. This event is not affected by core frequency changes (for example, P states, TM2 transitions) but has the same incrementing frequency as the time stamp counter. This event can approximate elapsed time while the core was not in a halt state. It is counted on a dedicated fixed counter, leaving the eight programmable counters available for other events. Note: On all current platforms this event stops counting during 'throttling (TM)' states duty off periods the processor is 'halted'.  The counter update is done at a lower clock rate then the core clock the overflow status bit for this counter may appear 'sticky'.  After the counter has overflowed and software clears the overflow status bit and resets the counter to less than MAX. The reset value to the counter is not clocked immediately so the overflow status bit will flip 'high (1)' and generate another PMI (if enabled) after which the reset value gets clocked into the counter. Therefore, software will get the interrupt, read the overflow status bit '1 for bit 34 while the counter value is less than MAX. Software should ignore this case.",
      "Counter": "Fixed counter 2",
      "PEBScounters": "34",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0x3c",
      "UMask": "0x00",
      "EventName": "CPU_CLK_UNHALTED.THREAD_P",
      "BriefDescription": "Thread cycles when thread is not in halt state",
      "PublicDescription": "This is an architectural event that counts the number of thread cycles while the thread is not in a halt state. The thread enters the halt state when it is running the HLT instruction. The core frequency may change from time to time due to power or thermal throttling. For this reason, this event may have a changing ratio with regards to wall clock time.",
      "Counter": "0,1,2,3,4,5,6,7",
      "PEBScounters": "0,1,2,3,4,5,6,7",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0x3c",
      "UMask": "0x01",
      "EventName": "CPU_CLK_UNHALTED.REF_TSC_P",
      "BriefDescription": "Reference cycles when the core is not in halt state.",
      "PublicDescription": "Counts the number of reference cycles when the core is not in a halt state. The core enters the halt state when it is running the HLT instruction or the MWAIT instruction. This event is not affected by core frequency changes (for example, P states, TM2 transitions) but has the same incrementing frequency as the time stamp counter. This event can approximate elapsed time while the core was not in a halt state. It is counted on a dedicated fixed counter, leaving the four (eight when Hyperthreading is disabled) programmable counters available for other events. Note: On all current platforms this event stops counting during 'throttling (TM)' states duty off periods the processor is 'halted'.  The counter update is done at a lower clock rate then the core clock the overflow status bit for this counter may appear 'sticky'.  After the counter has overflowed and software clears the overflow status bit and resets the counter to less than MAX. The reset value to the counter is not clocked immediately so the overflow status bit will flip 'high (1)' and generate another PMI (if enabled) after which the reset value gets clocked into the counter. Therefore, software will get the interrupt, read the overflow status bit '1 for bit 34 while the counter value is less than MAX. Software should ignore this case.",
      "Counter": "0,1,2,3,4,5,6,7",
      "PEBScounters": "0,1,2,3,4,5,6,7",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0x3c",
      "UMask": "0x02",
      "EventName": "CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE",
      "BriefDescription": "Core crystal clock cycles when this thread is unhalted and the other thread is halted.",
      "PublicDescription": "Counts Core crystal clock cycles when current thread is unhalted and the other thread is halted.",
      "Counter": "0,1,2,3,4,5,6,7",
      "PEBScounters": "0,1,2,3,4,5,6,7",
      "SampleAfterValue": "25003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0x3c",
      "UMask": "0x08",
      "EventName": "CPU_CLK_UNHALTED.REF_DISTRIBUTED",
      "BriefDescription": "Core crystal clock cycles. Cycle counts are evenly distributed between active threads in the Core.",
      "PublicDescription": "This event distributes Core crystal clock cycle counts between active hyperthreads, i.e., those in C0 sleep-state. A hyperthread becomes inactive when it executes the HLT or MWAIT instructions. If one thread is active in a core, all counts are attributed to this hyperthread. To obtain the full count when the Core is active, sum the counts from each hyperthread.",
      "Counter": "0,1,2,3,4,5,6,7",
      "PEBScounters": "0,1,2,3,4,5,6,7",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0xec",
      "UMask": "0x02",
      "EventName": "CPU_CLK_UNHALTED.DISTRIBUTED",
      "BriefDescription": "Cycle counts are evenly distributed between active threads in the Core.",
      "PublicDescription": "This event distributes cycle counts between active hyperthreads, i.e., those in C0.  A hyperthread becomes inactive when it executes the HLT or MWAIT instructions.  If all other hyperthreads are inactive (or disabled or do not exist), all counts are attributed to this hyperthread. To obtain the full count when the Core is active, sum the counts from each hyperthread.",
      "Counter": "0,1,2,3,4,5,6,7",
      "PEBScounters": "0,1,2,3,4,5,6,7",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0xec",
      "UMask": "0x10",
      "EventName": "CPU_CLK_UNHALTED.C01",
      "BriefDescription": "Core clocks when the thread is in the C0.1 light-weight slower wakeup time but more power saving optimized state.",
      "PublicDescription": "Counts core clocks when the thread is in the C0.1 light-weight slower wakeup time but more power saving optimized state.  This state can be entered via the TPAUSE or UMWAIT instructions.",
      "Counter": "0,1,2,3,4,5,6,7",
      "PEBScounters": "0,1,2,3,4,5,6,7",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0xec",
      "UMask": "0x20",
      "EventName": "CPU_CLK_UNHALTED.C02",
      "BriefDescription": "Core clocks when the thread is in the C0.2 light-weight faster wakeup time but less power saving optimized state.",
      "PublicDescription": "Counts core clocks when the thread is in the C0.2 light-weight faster wakeup time but less power saving optimized state.  This state can be entered via the TPAUSE or UMWAIT instructions.",
      "Counter": "0,1,2,3,4,5,6,7",
      "PEBScounters": "0,1,2,3,4,5,6,7",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0xec",
      "UMask": "0x40",
      "EventName": "CPU_CLK_UNHALTED.PAUSE",
      "BriefDescription": "CPU_CLK_UNHALTED.PAUSE",
      "PublicDescription": "CPU_CLK_UNHALTED.PAUSE",
      "Counter": "0,1,2,3,4,5,6,7",
      "PEBScounters": "0,1,2,3,4,5,6,7",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0xec",
      "UMask": "0x40",
      "EventName": "CPU_CLK_UNHALTED.PAUSE_INST",
      "BriefDescription": "CPU_CLK_UNHALTED.PAUSE_INST",
      "PublicDescription": "CPU_CLK_UNHALTED.PAUSE_INST",
      "Counter": "0,1,2,3,4,5,6,7",
      "PEBScounters": "0,1,2,3,4,5,6,7",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "1",
      "Invert": "0",
      "EdgeDetect": "1",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    },
    {
      "EventCode": "0xec",
      "UMask": "0x70",
      "EventName": "CPU_CLK_UNHALTED.C0_WAIT",
      "BriefDescription": "Core clocks when the thread is in the C0.1 or C0.2 or running a PAUSE in C0 ACPI state.",
      "PublicDescription": "Counts core clocks when the thread is in the C0.1 or C0.2 power saving optimized states (TPAUSE or UMWAIT instructions) or running the PAUSE instruction.",
      "Counter": "0,1,2,3,4,5,6,7",
      "PEBScounters": "0,1,2,3,4,5,6,7",
      "SampleAfterValue": "2000003",
      "MSRIndex": "0x00",
      "MSRValue": "0x00",
      "CollectPEBSRecord": "2",
      "TakenAlone": "0",
      "CounterMask": "0",
      "Invert": "0",
      "EdgeDetect": "0",
      "PEBS": "0",
      "Data_LA": "0",
      "L1_Hit_Indication": "0",
      "Errata": "null",
      "Offcore": "0",
      "Deprecated": "0",
      "Speculative": "1"
    }
  ]
}