package vsphere

import (
	"sync"
)

// WorkerFunc is a function that is supposed to do the actual work
// of the WorkerPool. It is similar to the "map" portion of the
// map/reduce semantics, in that it takes a single value as an input,
// does some processing and returns a single result.
type WorkerFunc func(interface{}) interface{}

// DrainerFunc represents a function used to "drain" the WorkerPool,
// i.e. pull out all the results generated by the workers and processing
// them. The DrainerFunc is called once per result produced.
type DrainerFunc func(interface{})

// FillerFunc represents a function for filling the WorkerPool with jobs.
// It is called once and is responsible for pushing jobs onto the supplied channel.
type FillerFunc func(chan interface{})

// WorkerPool implements a simple work pooling mechanism. It runs a predefined
// number of goroutines to process jobs. Jobs are inserted using the Fill call
// and results are retrieved through the Drain function.
type WorkerPool struct {
	wg  sync.WaitGroup
	In  chan interface{}
	Out chan interface{}
}

// NewWorkerPool creates a worker pool
func NewWorkerPool(bufsize int) *WorkerPool {
	return &WorkerPool{
		In:  make(chan interface{}, bufsize),
		Out: make(chan interface{}, bufsize),
	}
}

// Run takes a WorkerFunc and runs it in 'n' goroutines.
func (w *WorkerPool) Run(f WorkerFunc, n int) {
	w.wg.Add(1)
	go func() {
		defer w.wg.Done()
		var localWg sync.WaitGroup
		localWg.Add(n)
		for i := 0; i < n; i++ {
			go func() {
				defer localWg.Done()
				for job := range w.In {
					w.Out <- f(job)
				}
			}()
		}
		localWg.Wait()
		close(w.Out)
	}()
}

// Fill runs a FillerFunc responsible for supplying work to the pool. You may only
// call Fill once. Calling it twice will panic.
func (w *WorkerPool) Fill(f FillerFunc) {
	w.wg.Add(1)
	go func() {
		defer w.wg.Done()
		f(w.In)
		close(w.In)
	}()
}

// Drain runs a DrainerFunc for each result generated by the workers.
func (w *WorkerPool) Drain(f DrainerFunc) {
	w.wg.Add(1)
	go func() {
		defer w.wg.Done()
		for result := range w.Out {
			f(result)
		}
	}()
	w.wg.Wait()
}
