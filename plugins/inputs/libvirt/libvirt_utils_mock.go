// Code generated by mockery v2.46.3. DO NOT EDIT.

package libvirt

import (
	go_libvirt "github.com/digitalocean/go-libvirt"
	mock "github.com/stretchr/testify/mock"
)

// mockLibvirtUtils is an autogenerated mock type for the utils type
type mockLibvirtUtils struct {
	mock.Mock
}

// disconnect provides a mock function with given fields:
func (_m *mockLibvirtUtils) disconnect() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for disconnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ensureConnected provides a mock function with given fields: libvirtURI
func (_m *mockLibvirtUtils) ensureConnected(libvirtURI string) error {
	ret := _m.Called(libvirtURI)

	if len(ret) == 0 {
		panic("no return value specified for ensureConnected")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(libvirtURI)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// gatherAllDomains provides a mock function with given fields:
func (_m *mockLibvirtUtils) gatherAllDomains() ([]go_libvirt.Domain, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for gatherAllDomains")
	}

	var r0 []go_libvirt.Domain
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]go_libvirt.Domain, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []go_libvirt.Domain); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]go_libvirt.Domain)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// gatherNumberOfPCPUs provides a mock function with given fields:
func (_m *mockLibvirtUtils) gatherNumberOfPCPUs() (int, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for gatherNumberOfPCPUs")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func() (int, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// gatherStatsForDomains provides a mock function with given fields: domains, metricNumber
func (_m *mockLibvirtUtils) gatherStatsForDomains(domains []go_libvirt.Domain, metricNumber uint32) ([]go_libvirt.DomainStatsRecord, error) {
	ret := _m.Called(domains, metricNumber)

	if len(ret) == 0 {
		panic("no return value specified for gatherStatsForDomains")
	}

	var r0 []go_libvirt.DomainStatsRecord
	var r1 error
	if rf, ok := ret.Get(0).(func([]go_libvirt.Domain, uint32) ([]go_libvirt.DomainStatsRecord, error)); ok {
		return rf(domains, metricNumber)
	}
	if rf, ok := ret.Get(0).(func([]go_libvirt.Domain, uint32) []go_libvirt.DomainStatsRecord); ok {
		r0 = rf(domains, metricNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]go_libvirt.DomainStatsRecord)
		}
	}

	if rf, ok := ret.Get(1).(func([]go_libvirt.Domain, uint32) error); ok {
		r1 = rf(domains, metricNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// gatherVcpuMapping provides a mock function with given fields: domain, pCPUs, shouldGetCurrentPCPU
func (_m *mockLibvirtUtils) gatherVcpuMapping(domain go_libvirt.Domain, pCPUs int, shouldGetCurrentPCPU bool) ([]vcpuAffinity, error) {
	ret := _m.Called(domain, pCPUs, shouldGetCurrentPCPU)

	if len(ret) == 0 {
		panic("no return value specified for gatherVcpuMapping")
	}

	var r0 []vcpuAffinity
	var r1 error
	if rf, ok := ret.Get(0).(func(go_libvirt.Domain, int, bool) ([]vcpuAffinity, error)); ok {
		return rf(domain, pCPUs, shouldGetCurrentPCPU)
	}
	if rf, ok := ret.Get(0).(func(go_libvirt.Domain, int, bool) []vcpuAffinity); ok {
		r0 = rf(domain, pCPUs, shouldGetCurrentPCPU)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]vcpuAffinity)
		}
	}

	if rf, ok := ret.Get(1).(func(go_libvirt.Domain, int, bool) error); ok {
		r1 = rf(domain, pCPUs, shouldGetCurrentPCPU)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// newMockLibvirtUtils creates a new instance of mockLibvirtUtils. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockLibvirtUtils(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockLibvirtUtils {
	mock := &mockLibvirtUtils{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
