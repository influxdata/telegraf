// Code generated by mockery v2.14.0. DO NOT EDIT.

package libvirt

import (
	go_libvirt "github.com/digitalocean/go-libvirt"
	mock "github.com/stretchr/testify/mock"
)

// MockLibvirtUtils is an autogenerated mock type for the utils type
type MockLibvirtUtils struct {
	mock.Mock
}

// Disconnect provides a mock function with given fields:
func (_m *MockLibvirtUtils) Disconnect() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EnsureConnected provides a mock function with given fields: libvirtURI
func (_m *MockLibvirtUtils) EnsureConnected(libvirtURI string) error {
	ret := _m.Called(libvirtURI)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(libvirtURI)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GatherAllDomains provides a mock function with given fields:
func (_m *MockLibvirtUtils) GatherAllDomains() ([]go_libvirt.Domain, error) {
	ret := _m.Called()

	var r0 []go_libvirt.Domain
	if rf, ok := ret.Get(0).(func() []go_libvirt.Domain); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]go_libvirt.Domain)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GatherNumberOfPCPUs provides a mock function with given fields:
func (_m *MockLibvirtUtils) GatherNumberOfPCPUs() (int, error) {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GatherStatsForDomains provides a mock function with given fields: domains, metricNumber
func (_m *MockLibvirtUtils) GatherStatsForDomains(domains []go_libvirt.Domain, metricNumber uint32) ([]go_libvirt.DomainStatsRecord, error) {
	ret := _m.Called(domains, metricNumber)

	var r0 []go_libvirt.DomainStatsRecord
	if rf, ok := ret.Get(0).(func([]go_libvirt.Domain, uint32) []go_libvirt.DomainStatsRecord); ok {
		r0 = rf(domains, metricNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]go_libvirt.DomainStatsRecord)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]go_libvirt.Domain, uint32) error); ok {
		r1 = rf(domains, metricNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GatherVcpuMapping provides a mock function with given fields: domain, pCPUs, shouldGetCurrentPCPU
func (_m *MockLibvirtUtils) GatherVcpuMapping(domain go_libvirt.Domain, pCPUs int, shouldGetCurrentPCPU bool) ([]vcpuAffinity, error) {
	ret := _m.Called(domain, pCPUs, shouldGetCurrentPCPU)

	var r0 []vcpuAffinity
	if rf, ok := ret.Get(0).(func(go_libvirt.Domain, int, bool) []vcpuAffinity); ok {
		r0 = rf(domain, pCPUs, shouldGetCurrentPCPU)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]vcpuAffinity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(go_libvirt.Domain, int, bool) error); ok {
		r1 = rf(domain, pCPUs, shouldGetCurrentPCPU)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewMockLibvirtUtils interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockLibvirtUtils creates a new instance of MockLibvirtUtils. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockLibvirtUtils(t mockConstructorTestingTNewMockLibvirtUtils) *MockLibvirtUtils {
	mock := &MockLibvirtUtils{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
