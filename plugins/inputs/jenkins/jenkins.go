package jenkins

import (
	"net/http"

	"net/url"

	"fmt"

	"io"

	"encoding/json"

	"sync"
	"time"

	"strings"

	"github.com/influxdata/telegraf"
	"github.com/influxdata/telegraf/internal"
	"github.com/influxdata/telegraf/plugins/inputs"
)

type Jenkins struct {
	Servers []struct {
		Url   string
		Token string
	}
	client          *http.Client
	ResponseTimeout internal.Duration
}

type Fields map[string]interface{}
type Tags map[string]string

type parsedResponse struct {
	fields Fields
	tags   Tags
}

func (j *Jenkins) Description() string {
	return `Read Jenkins basic information, generated by Jenkins Metrics Plugin`
}

func (j *Jenkins) SampleConfig() string {
	return `
  # Jenkins server 1
	[[inputs.jenkins.servers]]
		url = "http://127.0.0.1:8080"
		token = "wvS2XYTNQf6K3Wciht17cBGJs9SKB_DFSYTDDG5mc-JYBPEhA6Tpc5LVcTlogUP1"
	`
}

func (j *Jenkins) Gather(acc telegraf.Accumulator) error {
	var wg sync.WaitGroup

	// Create an HTTP client that is re-used for each
	// collection interval
	if j.client == nil {
		client, err := j.createHttpClient()
		if err != nil {
			return err
		}
		j.client = client
	}

	for _, u := range j.Servers {
		uri := fmt.Sprintf("%s/metrics/%s/metrics", u.Url, u.Token)
		addr, err := url.Parse(uri)
		if err != nil {
			acc.AddError(fmt.Errorf("Unable to parse address '%s': %s", u, err))
			continue
		}

		wg.Add(1)
		go func(addr *url.URL) {
			defer wg.Done()
			acc.AddError(j.gatherUrl(addr, acc))
		}(addr)
	}

	wg.Wait()
	return nil
}

func (j *Jenkins) createHttpClient() (*http.Client, error) {
	if j.ResponseTimeout.Duration < time.Second {
		j.ResponseTimeout.Duration = time.Second * 5
	}

	client := &http.Client{
		Timeout: j.ResponseTimeout.Duration,
	}

	return client, nil
}

func (j *Jenkins) gatherUrl(addr *url.URL, acc telegraf.Accumulator) error {
	resp, err := j.client.Get(addr.String())
	if err != nil {
		return fmt.Errorf("error making HTTP request to %s: %s", addr.String(), err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("%s returned HTTP status %s", addr.String(), resp.Status)
	}

	parsed, err := parseResponse(resp.Body, addr.Host)
	if err != nil {
		return fmt.Errorf("Error parse response: %s", err)
	}
	for _, v := range parsed {
		acc.AddFields("jenkins", v.fields, v.tags)
	}
	return nil
}

type JenkinsData struct {
	Version                                      string
	Gauges, Counters, Histograms, Meters, Timers map[string]map[string]interface{}
}

func parseResponse(body io.Reader, server string) ([]parsedResponse, error) {
	jenkinsData := JenkinsData{}
	err := json.NewDecoder(body).Decode(&jenkinsData)
	if err != nil {
		return nil, err
	}
	parsed := []parsedResponse{}
	counters := parsedResponse{}
	counters.tags = Tags{}
	counters.fields = Fields{}
	counters.tags["server"] = server
	counters.tags["type"] = "counters"
	for k1, v1 := range jenkinsData.Counters {
		for k2, v2 := range v1 {
			counters.fields[k1+"."+k2] = v2
		}
	}
	parsed = append(parsed, counters)
	gauges := parsedResponse{}
	gauges.tags = Tags{}
	gauges.fields = Fields{}
	gauges.tags["server"] = server
	gauges.tags["type"] = "gauges"
	for k1, v1 := range jenkinsData.Gauges {
		if strings.HasPrefix(k1, "jenkins.versions") {
			continue
		}
		for k2, v2 := range v1 {
			gauges.fields[k1+"."+k2] = v2
		}
	}
	parsed = append(parsed, gauges)
	metrics := parsedResponse{}
	metrics.tags = Tags{}
	metrics.fields = Fields{}
	metrics.tags["server"] = server
	metrics.tags["type"] = "meters"
	for k1, v1 := range jenkinsData.Meters {
		for k2, v2 := range v1 {
			if k2 == "values" {
				continue
			}
			metrics.fields[k1+"."+k2] = v2
		}
	}
	parsed = append(parsed, metrics)
	timers := parsedResponse{}
	timers.tags = Tags{}
	timers.fields = Fields{}
	timers.tags["server"] = server
	timers.tags["type"] = "timers"
	for k1, v1 := range jenkinsData.Timers {
		for k2, v2 := range v1 {
			if k2 == "values" {
				continue
			}
			timers.fields[k1+"."+k2] = v2
		}
	}
	parsed = append(parsed, timers)
	return parsed, nil
}

func init() {
	inputs.Add("jenkins", func() telegraf.Input {
		return &Jenkins{}
	})
}
