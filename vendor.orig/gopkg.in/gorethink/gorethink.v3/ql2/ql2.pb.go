// Code generated by protoc-gen-go.
// source: ql2.proto
// DO NOT EDIT!

/*
Package ql2 is a generated protocol buffer package.

It is generated from these files:
	ql2.proto

It has these top-level messages:
	VersionDummy
	Query
	Frame
	Backtrace
	Response
	Datum
	Term
*/
package ql2

import proto "github.com/golang/protobuf/proto"
import json "encoding/json"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = &json.SyntaxError{}
var _ = math.Inf

// non-conforming protobuf libraries
// This enum contains the magic numbers for your version.  See **THE HIGH-LEVEL
// VIEW** for what to do with it.
type VersionDummy_Version int32

const (
	VersionDummy_V0_1 VersionDummy_Version = 1063369270
	VersionDummy_V0_2 VersionDummy_Version = 1915781601
	VersionDummy_V0_3 VersionDummy_Version = 1601562686
	VersionDummy_V0_4 VersionDummy_Version = 1074539808
	VersionDummy_V1_0 VersionDummy_Version = 885177795
)

var VersionDummy_Version_name = map[int32]string{
	1063369270: "V0_1",
	1915781601: "V0_2",
	1601562686: "V0_3",
	1074539808: "V0_4",
	885177795:  "V1_0",
}
var VersionDummy_Version_value = map[string]int32{
	"V0_1": 1063369270,
	"V0_2": 1915781601,
	"V0_3": 1601562686,
	"V0_4": 1074539808,
	"V1_0": 885177795,
}

func (x VersionDummy_Version) Enum() *VersionDummy_Version {
	p := new(VersionDummy_Version)
	*p = x
	return p
}
func (x VersionDummy_Version) String() string {
	return proto.EnumName(VersionDummy_Version_name, int32(x))
}
func (x VersionDummy_Version) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *VersionDummy_Version) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VersionDummy_Version_value, data, "VersionDummy_Version")
	if err != nil {
		return err
	}
	*x = VersionDummy_Version(value)
	return nil
}

// The protocol to use after the handshake, specified in V0_3
type VersionDummy_Protocol int32

const (
	VersionDummy_PROTOBUF VersionDummy_Protocol = 656407617
	VersionDummy_JSON     VersionDummy_Protocol = 2120839367
)

var VersionDummy_Protocol_name = map[int32]string{
	656407617:  "PROTOBUF",
	2120839367: "JSON",
}
var VersionDummy_Protocol_value = map[string]int32{
	"PROTOBUF": 656407617,
	"JSON":     2120839367,
}

func (x VersionDummy_Protocol) Enum() *VersionDummy_Protocol {
	p := new(VersionDummy_Protocol)
	*p = x
	return p
}
func (x VersionDummy_Protocol) String() string {
	return proto.EnumName(VersionDummy_Protocol_name, int32(x))
}
func (x VersionDummy_Protocol) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *VersionDummy_Protocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(VersionDummy_Protocol_value, data, "VersionDummy_Protocol")
	if err != nil {
		return err
	}
	*x = VersionDummy_Protocol(value)
	return nil
}

type Query_QueryType int32

const (
	Query_START    Query_QueryType = 1
	Query_CONTINUE Query_QueryType = 2
	// (see [Response]).
	Query_STOP         Query_QueryType = 3
	Query_NOREPLY_WAIT Query_QueryType = 4
	Query_SERVER_INFO  Query_QueryType = 5
)

var Query_QueryType_name = map[int32]string{
	1: "START",
	2: "CONTINUE",
	3: "STOP",
	4: "NOREPLY_WAIT",
	5: "SERVER_INFO",
}
var Query_QueryType_value = map[string]int32{
	"START":        1,
	"CONTINUE":     2,
	"STOP":         3,
	"NOREPLY_WAIT": 4,
	"SERVER_INFO":  5,
}

func (x Query_QueryType) Enum() *Query_QueryType {
	p := new(Query_QueryType)
	*p = x
	return p
}
func (x Query_QueryType) String() string {
	return proto.EnumName(Query_QueryType_name, int32(x))
}
func (x Query_QueryType) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *Query_QueryType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Query_QueryType_value, data, "Query_QueryType")
	if err != nil {
		return err
	}
	*x = Query_QueryType(value)
	return nil
}

type Frame_FrameType int32

const (
	Frame_POS Frame_FrameType = 1
	Frame_OPT Frame_FrameType = 2
)

var Frame_FrameType_name = map[int32]string{
	1: "POS",
	2: "OPT",
}
var Frame_FrameType_value = map[string]int32{
	"POS": 1,
	"OPT": 2,
}

func (x Frame_FrameType) Enum() *Frame_FrameType {
	p := new(Frame_FrameType)
	*p = x
	return p
}
func (x Frame_FrameType) String() string {
	return proto.EnumName(Frame_FrameType_name, int32(x))
}
func (x Frame_FrameType) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *Frame_FrameType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Frame_FrameType_value, data, "Frame_FrameType")
	if err != nil {
		return err
	}
	*x = Frame_FrameType(value)
	return nil
}

type Response_ResponseType int32

const (
	// These response types indicate success.
	Response_SUCCESS_ATOM     Response_ResponseType = 1
	Response_SUCCESS_SEQUENCE Response_ResponseType = 2
	Response_SUCCESS_PARTIAL  Response_ResponseType = 3
	// datatypes.  If you send a [CONTINUE] query with
	// the same token as this response, you will get
	// more of the sequence.  Keep sending [CONTINUE]
	// queries until you get back [SUCCESS_SEQUENCE].
	Response_WAIT_COMPLETE Response_ResponseType = 4
	Response_SERVER_INFO   Response_ResponseType = 5
	// These response types indicate failure.
	Response_CLIENT_ERROR Response_ResponseType = 16
	// client sends a malformed protobuf, or tries to
	// send [CONTINUE] for an unknown token.
	Response_COMPILE_ERROR Response_ResponseType = 17
	// checking.  For example, if you pass too many
	// arguments to a function.
	Response_RUNTIME_ERROR Response_ResponseType = 18
)

var Response_ResponseType_name = map[int32]string{
	1:  "SUCCESS_ATOM",
	2:  "SUCCESS_SEQUENCE",
	3:  "SUCCESS_PARTIAL",
	4:  "WAIT_COMPLETE",
	5:  "SERVER_INFO",
	16: "CLIENT_ERROR",
	17: "COMPILE_ERROR",
	18: "RUNTIME_ERROR",
}
var Response_ResponseType_value = map[string]int32{
	"SUCCESS_ATOM":     1,
	"SUCCESS_SEQUENCE": 2,
	"SUCCESS_PARTIAL":  3,
	"WAIT_COMPLETE":    4,
	"SERVER_INFO":      5,
	"CLIENT_ERROR":     16,
	"COMPILE_ERROR":    17,
	"RUNTIME_ERROR":    18,
}

func (x Response_ResponseType) Enum() *Response_ResponseType {
	p := new(Response_ResponseType)
	*p = x
	return p
}
func (x Response_ResponseType) String() string {
	return proto.EnumName(Response_ResponseType_name, int32(x))
}
func (x Response_ResponseType) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *Response_ResponseType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Response_ResponseType_value, data, "Response_ResponseType")
	if err != nil {
		return err
	}
	*x = Response_ResponseType(value)
	return nil
}

// If `ResponseType` is `RUNTIME_ERROR`, this may be filled in with more
// information about the error.
type Response_ErrorType int32

const (
	Response_INTERNAL         Response_ErrorType = 1000000
	Response_RESOURCE_LIMIT   Response_ErrorType = 2000000
	Response_QUERY_LOGIC      Response_ErrorType = 3000000
	Response_NON_EXISTENCE    Response_ErrorType = 3100000
	Response_OP_FAILED        Response_ErrorType = 4100000
	Response_OP_INDETERMINATE Response_ErrorType = 4200000
	Response_USER             Response_ErrorType = 5000000
	Response_PERMISSION_ERROR Response_ErrorType = 6000000
)

var Response_ErrorType_name = map[int32]string{
	1000000: "INTERNAL",
	2000000: "RESOURCE_LIMIT",
	3000000: "QUERY_LOGIC",
	3100000: "NON_EXISTENCE",
	4100000: "OP_FAILED",
	4200000: "OP_INDETERMINATE",
	5000000: "USER",
	6000000: "PERMISSION_ERROR",
}
var Response_ErrorType_value = map[string]int32{
	"INTERNAL":         1000000,
	"RESOURCE_LIMIT":   2000000,
	"QUERY_LOGIC":      3000000,
	"NON_EXISTENCE":    3100000,
	"OP_FAILED":        4100000,
	"OP_INDETERMINATE": 4200000,
	"USER":             5000000,
	"PERMISSION_ERROR": 6000000,
}

func (x Response_ErrorType) Enum() *Response_ErrorType {
	p := new(Response_ErrorType)
	*p = x
	return p
}
func (x Response_ErrorType) String() string {
	return proto.EnumName(Response_ErrorType_name, int32(x))
}
func (x Response_ErrorType) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *Response_ErrorType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Response_ErrorType_value, data, "Response_ErrorType")
	if err != nil {
		return err
	}
	*x = Response_ErrorType(value)
	return nil
}

// ResponseNotes are used to provide information about the query
// response that may be useful for people writing drivers or ORMs.
// Currently all the notes we send indicate that a stream has certain
// special properties.
type Response_ResponseNote int32

const (
	// The stream is a changefeed stream (e.g. `r.table('test').changes()`).
	Response_SEQUENCE_FEED Response_ResponseNote = 1
	// The stream is a point changefeed stream
	// (e.g. `r.table('test').get(0).changes()`).
	Response_ATOM_FEED Response_ResponseNote = 2
	// The stream is an order_by_limit changefeed stream
	// (e.g. `r.table('test').order_by(index: 'id').limit(5).changes()`).
	Response_ORDER_BY_LIMIT_FEED Response_ResponseNote = 3
	// The stream is a union of multiple changefeed types that can't be
	// collapsed to a single type
	// (e.g. `r.table('test').changes().union(r.table('test').get(0).changes())`).
	Response_UNIONED_FEED Response_ResponseNote = 4
	// The stream is a changefeed stream and includes notes on what state
	// the changefeed stream is in (e.g. objects of the form `{state:
	// 'initializing'}`).
	Response_INCLUDES_STATES Response_ResponseNote = 5
)

var Response_ResponseNote_name = map[int32]string{
	1: "SEQUENCE_FEED",
	2: "ATOM_FEED",
	3: "ORDER_BY_LIMIT_FEED",
	4: "UNIONED_FEED",
	5: "INCLUDES_STATES",
}
var Response_ResponseNote_value = map[string]int32{
	"SEQUENCE_FEED":       1,
	"ATOM_FEED":           2,
	"ORDER_BY_LIMIT_FEED": 3,
	"UNIONED_FEED":        4,
	"INCLUDES_STATES":     5,
}

func (x Response_ResponseNote) Enum() *Response_ResponseNote {
	p := new(Response_ResponseNote)
	*p = x
	return p
}
func (x Response_ResponseNote) String() string {
	return proto.EnumName(Response_ResponseNote_name, int32(x))
}
func (x Response_ResponseNote) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *Response_ResponseNote) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Response_ResponseNote_value, data, "Response_ResponseNote")
	if err != nil {
		return err
	}
	*x = Response_ResponseNote(value)
	return nil
}

type Datum_DatumType int32

const (
	Datum_R_NULL   Datum_DatumType = 1
	Datum_R_BOOL   Datum_DatumType = 2
	Datum_R_NUM    Datum_DatumType = 3
	Datum_R_STR    Datum_DatumType = 4
	Datum_R_ARRAY  Datum_DatumType = 5
	Datum_R_OBJECT Datum_DatumType = 6
	// This [DatumType] will only be used if [accepts_r_json] is
	// set to [true] in [Query].  [r_str] will be filled with a
	// JSON encoding of the [Datum].
	Datum_R_JSON Datum_DatumType = 7
)

var Datum_DatumType_name = map[int32]string{
	1: "R_NULL",
	2: "R_BOOL",
	3: "R_NUM",
	4: "R_STR",
	5: "R_ARRAY",
	6: "R_OBJECT",
	7: "R_JSON",
}
var Datum_DatumType_value = map[string]int32{
	"R_NULL":   1,
	"R_BOOL":   2,
	"R_NUM":    3,
	"R_STR":    4,
	"R_ARRAY":  5,
	"R_OBJECT": 6,
	"R_JSON":   7,
}

func (x Datum_DatumType) Enum() *Datum_DatumType {
	p := new(Datum_DatumType)
	*p = x
	return p
}
func (x Datum_DatumType) String() string {
	return proto.EnumName(Datum_DatumType_name, int32(x))
}
func (x Datum_DatumType) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *Datum_DatumType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Datum_DatumType_value, data, "Datum_DatumType")
	if err != nil {
		return err
	}
	*x = Datum_DatumType(value)
	return nil
}

type Term_TermType int32

const (
	// A RQL datum, stored in `datum` below.
	Term_DATUM      Term_TermType = 1
	Term_MAKE_ARRAY Term_TermType = 2
	// Evaluate the terms in [optargs] and make an object
	Term_MAKE_OBJ Term_TermType = 3
	// Takes an integer representing a variable and returns the value stored
	// in that variable.  It's the responsibility of the client to translate
	// from their local representation of a variable to a unique _non-negative_
	// integer for that variable.  (We do it this way instead of letting
	// clients provide variable names as strings to discourage
	// variable-capturing client libraries, and because it's more efficient
	// on the wire.)
	Term_VAR Term_TermType = 10
	// Takes some javascript code and executes it.
	Term_JAVASCRIPT Term_TermType = 11
	// STRING {timeout: !NUMBER} -> Function(*)
	Term_UUID Term_TermType = 169
	// Takes an HTTP URL and gets it.  If the get succeeds and
	//  returns valid JSON, it is converted into a DATUM
	Term_HTTP Term_TermType = 153
	// Takes a string and throws an error with that message.
	// Inside of a `default` block, you can omit the first
	// argument to rethrow whatever error you catch (this is most
	// useful as an argument to the `default` filter optarg).
	Term_ERROR Term_TermType = 12
	// Takes nothing and returns a reference to the implicit variable.
	Term_IMPLICIT_VAR Term_TermType = 13
	// * Data Operators
	// Returns a reference to a database.
	Term_DB Term_TermType = 14
	// Returns a reference to a table.
	Term_TABLE Term_TermType = 15
	// STRING, {read_mode:STRING, identifier_format:STRING} -> Table
	// Gets a single element from a table by its primary or a secondary key.
	Term_GET Term_TermType = 16
	// Table, STRING -> NULL            | Table, NUMBER -> NULL |
	Term_GET_ALL Term_TermType = 78
	// Simple DATUM Ops
	Term_EQ  Term_TermType = 17
	Term_NE  Term_TermType = 18
	Term_LT  Term_TermType = 19
	Term_LE  Term_TermType = 20
	Term_GT  Term_TermType = 21
	Term_GE  Term_TermType = 22
	Term_NOT Term_TermType = 23
	// ADD can either add two numbers or concatenate two arrays.
	Term_ADD   Term_TermType = 24
	Term_SUB   Term_TermType = 25
	Term_MUL   Term_TermType = 26
	Term_DIV   Term_TermType = 27
	Term_MOD   Term_TermType = 28
	Term_FLOOR Term_TermType = 183
	Term_CEIL  Term_TermType = 184
	Term_ROUND Term_TermType = 185
	// DATUM Array Ops
	// Append a single element to the end of an array (like `snoc`).
	Term_APPEND Term_TermType = 29
	// Prepend a single element to the end of an array (like `cons`).
	Term_PREPEND Term_TermType = 80
	// Remove the elements of one array from another array.
	Term_DIFFERENCE Term_TermType = 95
	// DATUM Set Ops
	// Set ops work on arrays. They don't use actual sets and thus have
	// performance characteristics you would expect from arrays rather than
	// from sets. All set operations have the post condition that they
	// array they return contains no duplicate values.
	Term_SET_INSERT       Term_TermType = 88
	Term_SET_INTERSECTION Term_TermType = 89
	Term_SET_UNION        Term_TermType = 90
	Term_SET_DIFFERENCE   Term_TermType = 91
	Term_SLICE            Term_TermType = 30
	Term_SKIP             Term_TermType = 70
	Term_LIMIT            Term_TermType = 71
	Term_OFFSETS_OF       Term_TermType = 87
	Term_CONTAINS         Term_TermType = 93
	// Stream/Object Ops
	// Get a particular field from an object, or map that over a
	// sequence.
	Term_GET_FIELD Term_TermType = 31
	// | Sequence, STRING -> Sequence
	// Return an array containing the keys of the object.
	Term_KEYS Term_TermType = 94
	// Return an array containing the values of the object.
	Term_VALUES Term_TermType = 186
	// Creates an object
	Term_OBJECT Term_TermType = 143
	// Check whether an object contains all the specified fields,
	// or filters a sequence so that all objects inside of it
	// contain all the specified fields.
	Term_HAS_FIELDS Term_TermType = 32
	// x.with_fields(...) <=> x.has_fields(...).pluck(...)
	Term_WITH_FIELDS Term_TermType = 96
	// Get a subset of an object by selecting some attributes to preserve,
	// or map that over a sequence.  (Both pick and pluck, polymorphic.)
	Term_PLUCK Term_TermType = 33
	// Get a subset of an object by selecting some attributes to discard, or
	// map that over a sequence.  (Both unpick and without, polymorphic.)
	Term_WITHOUT Term_TermType = 34
	// Merge objects (right-preferential)
	Term_MERGE Term_TermType = 35
	// Sequence Ops
	// Get all elements of a sequence between two values.
	// Half-open by default, but the openness of either side can be
	// changed by passing 'closed' or 'open for `right_bound` or
	// `left_bound`.
	Term_BETWEEN_DEPRECATED Term_TermType = 36
	// With the newer version, clients should use `r.minval` and `r.maxval` for unboundedness
	Term_BETWEEN Term_TermType = 182
	Term_REDUCE  Term_TermType = 37
	Term_MAP     Term_TermType = 38
	Term_FOLD    Term_TermType = 187
	// Filter a sequence with either a function or a shortcut
	// object (see API docs for details).  The body of FILTER is
	// wrapped in an implicit `.default(false)`, and you can
	// change the default value by specifying the `default`
	// optarg.  If you make the default `r.error`, all errors
	// caught by `default` will be rethrown as if the `default`
	// did not exist.
	Term_FILTER Term_TermType = 39
	// Sequence, OBJECT, {default:DATUM} -> Sequence
	// Map a function over a sequence and then concatenate the results together.
	Term_CONCAT_MAP Term_TermType = 40
	// Order a sequence based on one or more attributes.
	Term_ORDER_BY Term_TermType = 41
	// Get all distinct elements of a sequence (like `uniq`).
	Term_DISTINCT Term_TermType = 42
	// Count the number of elements in a sequence, or only the elements that match
	// a given filter.
	Term_COUNT    Term_TermType = 43
	Term_IS_EMPTY Term_TermType = 86
	// Take the union of multiple sequences (preserves duplicate elements! (use distinct)).
	Term_UNION Term_TermType = 44
	// Get the Nth element of a sequence.
	Term_NTH Term_TermType = 45
	// do NTH or GET_FIELD depending on target object
	Term_BRACKET    Term_TermType = 170
	Term_INNER_JOIN Term_TermType = 48
	Term_OUTER_JOIN Term_TermType = 49
	// An inner-join that does an equality comparison on two attributes.
	Term_EQ_JOIN Term_TermType = 50
	Term_ZIP     Term_TermType = 72
	Term_RANGE   Term_TermType = 173
	// Array Ops
	// Insert an element in to an array at a given index.
	Term_INSERT_AT Term_TermType = 82
	// Remove an element at a given index from an array.
	Term_DELETE_AT Term_TermType = 83
	// ARRAY, NUMBER, NUMBER -> ARRAY
	// Change the element at a given index of an array.
	Term_CHANGE_AT Term_TermType = 84
	// Splice one array in to another array.
	Term_SPLICE_AT Term_TermType = 85
	// * Type Ops
	// Coerces a datum to a named type (e.g. "bool").
	// If you previously used `stream_to_array`, you should use this instead
	// with the type "array".
	Term_COERCE_TO Term_TermType = 51
	// Returns the named type of a datum (e.g. TYPE_OF(true) = "BOOL")
	Term_TYPE_OF Term_TermType = 52
	// * Write Ops (the OBJECTs contain data about number of errors etc.)
	// Updates all the rows in a selection.  Calls its Function with the row
	// to be updated, and then merges the result of that call.
	Term_UPDATE Term_TermType = 53
	// SingleSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
	// StreamSelection, OBJECT,      {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
	// SingleSelection, OBJECT,      {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT
	// Deletes all the rows in a selection.
	Term_DELETE Term_TermType = 54
	// Replaces all the rows in a selection.  Calls its Function with the row
	// to be replaced, and then discards it and stores the result of that
	// call.
	Term_REPLACE Term_TermType = 55
	// Inserts into a table.  If `conflict` is replace, overwrites
	// entries with the same primary key.  If `conflict` is
	// update, does an update on the entry.  If `conflict` is
	// error, or is omitted, conflicts will trigger an error.
	Term_INSERT Term_TermType = 56
	// * Administrative OPs
	// Creates a database with a particular name.
	Term_DB_CREATE Term_TermType = 57
	// Drops a database with a particular name.
	Term_DB_DROP Term_TermType = 58
	// Lists all the databases by name.  (Takes no arguments)
	Term_DB_LIST Term_TermType = 59
	// Creates a table with a particular name in a particular
	// database.  (You may omit the first argument to use the
	// default database.)
	Term_TABLE_CREATE Term_TermType = 60
	// Database, STRING, {primary_key:STRING, shards:NUMBER, replicas:OBJECT, primary_replica_tag:STRING} -> OBJECT
	// STRING, {primary_key:STRING, shards:NUMBER, replicas:NUMBER, primary_replica_tag:STRING} -> OBJECT
	// STRING, {primary_key:STRING, shards:NUMBER, replicas:OBJECT, primary_replica_tag:STRING} -> OBJECT
	// Drops a table with a particular name from a particular
	// database.  (You may omit the first argument to use the
	// default database.)
	Term_TABLE_DROP Term_TermType = 61
	// STRING -> OBJECT
	// Lists all the tables in a particular database.  (You may
	// omit the first argument to use the default database.)
	Term_TABLE_LIST Term_TermType = 62
	//  -> ARRAY
	// Returns the row in the `rethinkdb.table_config` or `rethinkdb.db_config` table
	// that corresponds to the given database or table.
	Term_CONFIG Term_TermType = 174
	// Table -> SingleSelection
	// Returns the row in the `rethinkdb.table_status` table that corresponds to the
	// given table.
	Term_STATUS Term_TermType = 175
	// Called on a table, waits for that table to be ready for read/write operations.
	// Called on a database, waits for all of the tables in the database to be ready.
	// Returns the corresponding row or rows from the `rethinkdb.table_status` table.
	Term_WAIT Term_TermType = 177
	// Database -> OBJECT
	// Generates a new config for the given table, or all tables in the given database
	// The `shards` and `replicas` arguments are required. If `emergency_repair` is
	// specified, it will enter a completely different mode of repairing a table
	// which has lost half or more of its replicas.
	Term_RECONFIGURE Term_TermType = 176
	//                  dry_run:BOOLEAN]
	//                 } -> OBJECT
	// Database|Table, {shards:NUMBER, replicas:OBJECT [,
	//                  primary_replica_tag:STRING,
	//                  nonvoting_replica_tags:ARRAY,
	//                  dry_run:BOOLEAN]
	//                 } -> OBJECT
	// Table, {emergency_repair:STRING, dry_run:BOOLEAN} -> OBJECT
	// Balances the table's shards but leaves everything else the same. Can also be
	// applied to an entire database at once.
	Term_REBALANCE Term_TermType = 179
	// Ensures that previously issued soft-durability writes are complete and
	// written to disk.
	Term_SYNC Term_TermType = 138
	// Set global, database, or table-specific permissions
	Term_GRANT Term_TermType = 188
	// * Secondary indexes OPs
	// Creates a new secondary index with a particular name and definition.
	Term_INDEX_CREATE Term_TermType = 75
	// Drops a secondary index with a particular name from the specified table.
	Term_INDEX_DROP Term_TermType = 76
	// Lists all secondary indexes on a particular table.
	Term_INDEX_LIST Term_TermType = 77
	// Gets information about whether or not a set of indexes are ready to
	// be accessed. Returns a list of objects that look like this:
	// {index:STRING, ready:BOOL[, progress:NUMBER]}
	Term_INDEX_STATUS Term_TermType = 139
	// Blocks until a set of indexes are ready to be accessed. Returns the
	// same values INDEX_STATUS.
	Term_INDEX_WAIT Term_TermType = 140
	// Renames the given index to a new name
	Term_INDEX_RENAME Term_TermType = 156
	// * Control Operators
	// Calls a function on data
	Term_FUNCALL Term_TermType = 64
	// Executes its first argument, and returns its second argument if it
	// got [true] or its third argument if it got [false] (like an `if`
	// statement).
	Term_BRANCH Term_TermType = 65
	// Returns true if any of its arguments returns true (short-circuits).
	Term_OR Term_TermType = 66
	// Returns true if all of its arguments return true (short-circuits).
	Term_AND Term_TermType = 67
	// Calls its Function with each entry in the sequence
	// and executes the array of terms that Function returns.
	Term_FOR_EACH Term_TermType = 68
	// An anonymous function.  Takes an array of numbers representing
	// variables (see [VAR] above), and a [Term] to execute with those in
	// scope.  Returns a function that may be passed an array of arguments,
	// then executes the Term with those bound to the variable names.  The
	// user will never construct this directly.  We use it internally for
	// things like `map` which take a function.  The "arity" of a [Function] is
	// the number of arguments it takes.
	// For example, here's what `_X_.map{|x| x+2}` turns into:
	// Term {
	//   type = MAP;
	//   args = [_X_,
	//           Term {
	//             type = Function;
	//             args = [Term {
	//                       type = DATUM;
	//                       datum = Datum {
	//                         type = R_ARRAY;
	//                         r_array = [Datum { type = R_NUM; r_num = 1; }];
	//                       };
	//                     },
	//                     Term {
	//                       type = ADD;
	//                       args = [Term {
	//                                 type = VAR;
	//                                 args = [Term {
	//                                           type = DATUM;
	//                                           datum = Datum { type = R_NUM;
	//                                                           r_num = 1};
	//                                         }];
	//                               },
	//                               Term {
	//                                 type = DATUM;
	//                                 datum = Datum { type = R_NUM; r_num = 2; };
	//                               }];
	//                     }];
	//           }];
	Term_FUNC Term_TermType = 69
	// Indicates to ORDER_BY that this attribute is to be sorted in ascending order.
	Term_ASC Term_TermType = 73
	// Indicates to ORDER_BY that this attribute is to be sorted in descending order.
	Term_DESC Term_TermType = 74
	// Gets info about anything.  INFO is most commonly called on tables.
	Term_INFO Term_TermType = 79
	// `a.match(b)` returns a match object if the string `a`
	// matches the regular expression `b`.
	Term_MATCH Term_TermType = 97
	// Change the case of a string.
	Term_UPCASE   Term_TermType = 141
	Term_DOWNCASE Term_TermType = 142
	// Select a number of elements from sequence with uniform distribution.
	Term_SAMPLE Term_TermType = 81
	// Evaluates its first argument.  If that argument returns
	// NULL or throws an error related to the absence of an
	// expected value (for instance, accessing a non-existent
	// field or adding NULL to an integer), DEFAULT will either
	// return its second argument or execute it if it's a
	// function.  If the second argument is a function, it will be
	// passed either the text of the error or NULL as its
	// argument.
	Term_DEFAULT Term_TermType = 92
	// Parses its first argument as a json string and returns it as a
	// datum.
	Term_JSON Term_TermType = 98
	// Returns the datum as a JSON string.
	// N.B.: we would really prefer this be named TO_JSON and that exists as
	// an alias in Python and JavaScript drivers; however it conflicts with the
	// standard `to_json` method defined by Ruby's standard json library.
	Term_TO_JSON_STRING Term_TermType = 172
	// Parses its first arguments as an ISO 8601 time and returns it as a
	// datum.
	Term_ISO8601 Term_TermType = 99
	// Prints a time as an ISO 8601 time.
	Term_TO_ISO8601 Term_TermType = 100
	// Returns a time given seconds since epoch in UTC.
	Term_EPOCH_TIME Term_TermType = 101
	// Returns seconds since epoch in UTC given a time.
	Term_TO_EPOCH_TIME Term_TermType = 102
	// The time the query was received by the server.
	Term_NOW Term_TermType = 103
	// Puts a time into an ISO 8601 timezone.
	Term_IN_TIMEZONE Term_TermType = 104
	// a.during(b, c) returns whether a is in the range [b, c)
	Term_DURING Term_TermType = 105
	// Retrieves the date portion of a time.
	Term_DATE Term_TermType = 106
	// x.time_of_day == x.date - x
	Term_TIME_OF_DAY Term_TermType = 126
	// Returns the timezone of a time.
	Term_TIMEZONE Term_TermType = 127
	// These access the various components of a time.
	Term_YEAR        Term_TermType = 128
	Term_MONTH       Term_TermType = 129
	Term_DAY         Term_TermType = 130
	Term_DAY_OF_WEEK Term_TermType = 131
	Term_DAY_OF_YEAR Term_TermType = 132
	Term_HOURS       Term_TermType = 133
	Term_MINUTES     Term_TermType = 134
	Term_SECONDS     Term_TermType = 135
	// Construct a time from a date and optional timezone or a
	// date+time and optional timezone.
	Term_TIME Term_TermType = 136
	// Constants for ISO 8601 days of the week.
	Term_MONDAY    Term_TermType = 107
	Term_TUESDAY   Term_TermType = 108
	Term_WEDNESDAY Term_TermType = 109
	Term_THURSDAY  Term_TermType = 110
	Term_FRIDAY    Term_TermType = 111
	Term_SATURDAY  Term_TermType = 112
	Term_SUNDAY    Term_TermType = 113
	// Constants for ISO 8601 months.
	Term_JANUARY   Term_TermType = 114
	Term_FEBRUARY  Term_TermType = 115
	Term_MARCH     Term_TermType = 116
	Term_APRIL     Term_TermType = 117
	Term_MAY       Term_TermType = 118
	Term_JUNE      Term_TermType = 119
	Term_JULY      Term_TermType = 120
	Term_AUGUST    Term_TermType = 121
	Term_SEPTEMBER Term_TermType = 122
	Term_OCTOBER   Term_TermType = 123
	Term_NOVEMBER  Term_TermType = 124
	Term_DECEMBER  Term_TermType = 125
	// Indicates to MERGE to replace, or remove in case of an empty literal, the
	// other object rather than merge it.
	Term_LITERAL Term_TermType = 137
	// SEQUENCE, STRING -> GROUPED_SEQUENCE | SEQUENCE, FUNCTION -> GROUPED_SEQUENCE
	Term_GROUP Term_TermType = 144
	Term_SUM   Term_TermType = 145
	Term_AVG   Term_TermType = 146
	Term_MIN   Term_TermType = 147
	Term_MAX   Term_TermType = 148
	// `str.split()` splits on whitespace
	// `str.split(" ")` splits on spaces only
	// `str.split(" ", 5)` splits on spaces with at most 5 results
	// `str.split(nil, 5)` splits on whitespace with at most 5 results
	Term_SPLIT   Term_TermType = 149
	Term_UNGROUP Term_TermType = 150
	// Takes a range of numbers and returns a random number within the range
	Term_RANDOM  Term_TermType = 151
	Term_CHANGES Term_TermType = 152
	Term_ARGS    Term_TermType = 154
	// BINARY is client-only at the moment, it is not supported on the server
	Term_BINARY           Term_TermType = 155
	Term_GEOJSON          Term_TermType = 157
	Term_TO_GEOJSON       Term_TermType = 158
	Term_POINT            Term_TermType = 159
	Term_LINE             Term_TermType = 160
	Term_POLYGON          Term_TermType = 161
	Term_DISTANCE         Term_TermType = 162
	Term_INTERSECTS       Term_TermType = 163
	Term_INCLUDES         Term_TermType = 164
	Term_CIRCLE           Term_TermType = 165
	Term_GET_INTERSECTING Term_TermType = 166
	Term_FILL             Term_TermType = 167
	Term_GET_NEAREST      Term_TermType = 168
	Term_POLYGON_SUB      Term_TermType = 171
	// Constants for specifying key ranges
	Term_MINVAL Term_TermType = 180
	Term_MAXVAL Term_TermType = 181
)

var Term_TermType_name = map[int32]string{
	1:   "DATUM",
	2:   "MAKE_ARRAY",
	3:   "MAKE_OBJ",
	10:  "VAR",
	11:  "JAVASCRIPT",
	169: "UUID",
	153: "HTTP",
	12:  "ERROR",
	13:  "IMPLICIT_VAR",
	14:  "DB",
	15:  "TABLE",
	16:  "GET",
	78:  "GET_ALL",
	17:  "EQ",
	18:  "NE",
	19:  "LT",
	20:  "LE",
	21:  "GT",
	22:  "GE",
	23:  "NOT",
	24:  "ADD",
	25:  "SUB",
	26:  "MUL",
	27:  "DIV",
	28:  "MOD",
	183: "FLOOR",
	184: "CEIL",
	185: "ROUND",
	29:  "APPEND",
	80:  "PREPEND",
	95:  "DIFFERENCE",
	88:  "SET_INSERT",
	89:  "SET_INTERSECTION",
	90:  "SET_UNION",
	91:  "SET_DIFFERENCE",
	30:  "SLICE",
	70:  "SKIP",
	71:  "LIMIT",
	87:  "OFFSETS_OF",
	93:  "CONTAINS",
	31:  "GET_FIELD",
	94:  "KEYS",
	186: "VALUES",
	143: "OBJECT",
	32:  "HAS_FIELDS",
	96:  "WITH_FIELDS",
	33:  "PLUCK",
	34:  "WITHOUT",
	35:  "MERGE",
	36:  "BETWEEN_DEPRECATED",
	182: "BETWEEN",
	37:  "REDUCE",
	38:  "MAP",
	187: "FOLD",
	39:  "FILTER",
	40:  "CONCAT_MAP",
	41:  "ORDER_BY",
	42:  "DISTINCT",
	43:  "COUNT",
	86:  "IS_EMPTY",
	44:  "UNION",
	45:  "NTH",
	170: "BRACKET",
	48:  "INNER_JOIN",
	49:  "OUTER_JOIN",
	50:  "EQ_JOIN",
	72:  "ZIP",
	173: "RANGE",
	82:  "INSERT_AT",
	83:  "DELETE_AT",
	84:  "CHANGE_AT",
	85:  "SPLICE_AT",
	51:  "COERCE_TO",
	52:  "TYPE_OF",
	53:  "UPDATE",
	54:  "DELETE",
	55:  "REPLACE",
	56:  "INSERT",
	57:  "DB_CREATE",
	58:  "DB_DROP",
	59:  "DB_LIST",
	60:  "TABLE_CREATE",
	61:  "TABLE_DROP",
	62:  "TABLE_LIST",
	174: "CONFIG",
	175: "STATUS",
	177: "WAIT",
	176: "RECONFIGURE",
	179: "REBALANCE",
	138: "SYNC",
	188: "GRANT",
	75:  "INDEX_CREATE",
	76:  "INDEX_DROP",
	77:  "INDEX_LIST",
	139: "INDEX_STATUS",
	140: "INDEX_WAIT",
	156: "INDEX_RENAME",
	64:  "FUNCALL",
	65:  "BRANCH",
	66:  "OR",
	67:  "AND",
	68:  "FOR_EACH",
	69:  "FUNC",
	73:  "ASC",
	74:  "DESC",
	79:  "INFO",
	97:  "MATCH",
	141: "UPCASE",
	142: "DOWNCASE",
	81:  "SAMPLE",
	92:  "DEFAULT",
	98:  "JSON",
	172: "TO_JSON_STRING",
	99:  "ISO8601",
	100: "TO_ISO8601",
	101: "EPOCH_TIME",
	102: "TO_EPOCH_TIME",
	103: "NOW",
	104: "IN_TIMEZONE",
	105: "DURING",
	106: "DATE",
	126: "TIME_OF_DAY",
	127: "TIMEZONE",
	128: "YEAR",
	129: "MONTH",
	130: "DAY",
	131: "DAY_OF_WEEK",
	132: "DAY_OF_YEAR",
	133: "HOURS",
	134: "MINUTES",
	135: "SECONDS",
	136: "TIME",
	107: "MONDAY",
	108: "TUESDAY",
	109: "WEDNESDAY",
	110: "THURSDAY",
	111: "FRIDAY",
	112: "SATURDAY",
	113: "SUNDAY",
	114: "JANUARY",
	115: "FEBRUARY",
	116: "MARCH",
	117: "APRIL",
	118: "MAY",
	119: "JUNE",
	120: "JULY",
	121: "AUGUST",
	122: "SEPTEMBER",
	123: "OCTOBER",
	124: "NOVEMBER",
	125: "DECEMBER",
	137: "LITERAL",
	144: "GROUP",
	145: "SUM",
	146: "AVG",
	147: "MIN",
	148: "MAX",
	149: "SPLIT",
	150: "UNGROUP",
	151: "RANDOM",
	152: "CHANGES",
	154: "ARGS",
	155: "BINARY",
	157: "GEOJSON",
	158: "TO_GEOJSON",
	159: "POINT",
	160: "LINE",
	161: "POLYGON",
	162: "DISTANCE",
	163: "INTERSECTS",
	164: "INCLUDES",
	165: "CIRCLE",
	166: "GET_INTERSECTING",
	167: "FILL",
	168: "GET_NEAREST",
	171: "POLYGON_SUB",
	180: "MINVAL",
	181: "MAXVAL",
}
var Term_TermType_value = map[string]int32{
	"DATUM":              1,
	"MAKE_ARRAY":         2,
	"MAKE_OBJ":           3,
	"VAR":                10,
	"JAVASCRIPT":         11,
	"UUID":               169,
	"HTTP":               153,
	"ERROR":              12,
	"IMPLICIT_VAR":       13,
	"DB":                 14,
	"TABLE":              15,
	"GET":                16,
	"GET_ALL":            78,
	"EQ":                 17,
	"NE":                 18,
	"LT":                 19,
	"LE":                 20,
	"GT":                 21,
	"GE":                 22,
	"NOT":                23,
	"ADD":                24,
	"SUB":                25,
	"MUL":                26,
	"DIV":                27,
	"MOD":                28,
	"FLOOR":              183,
	"CEIL":               184,
	"ROUND":              185,
	"APPEND":             29,
	"PREPEND":            80,
	"DIFFERENCE":         95,
	"SET_INSERT":         88,
	"SET_INTERSECTION":   89,
	"SET_UNION":          90,
	"SET_DIFFERENCE":     91,
	"SLICE":              30,
	"SKIP":               70,
	"LIMIT":              71,
	"OFFSETS_OF":         87,
	"CONTAINS":           93,
	"GET_FIELD":          31,
	"KEYS":               94,
	"VALUES":             186,
	"OBJECT":             143,
	"HAS_FIELDS":         32,
	"WITH_FIELDS":        96,
	"PLUCK":              33,
	"WITHOUT":            34,
	"MERGE":              35,
	"BETWEEN_DEPRECATED": 36,
	"BETWEEN":            182,
	"REDUCE":             37,
	"MAP":                38,
	"FOLD":               187,
	"FILTER":             39,
	"CONCAT_MAP":         40,
	"ORDER_BY":           41,
	"DISTINCT":           42,
	"COUNT":              43,
	"IS_EMPTY":           86,
	"UNION":              44,
	"NTH":                45,
	"BRACKET":            170,
	"INNER_JOIN":         48,
	"OUTER_JOIN":         49,
	"EQ_JOIN":            50,
	"ZIP":                72,
	"RANGE":              173,
	"INSERT_AT":          82,
	"DELETE_AT":          83,
	"CHANGE_AT":          84,
	"SPLICE_AT":          85,
	"COERCE_TO":          51,
	"TYPE_OF":            52,
	"UPDATE":             53,
	"DELETE":             54,
	"REPLACE":            55,
	"INSERT":             56,
	"DB_CREATE":          57,
	"DB_DROP":            58,
	"DB_LIST":            59,
	"TABLE_CREATE":       60,
	"TABLE_DROP":         61,
	"TABLE_LIST":         62,
	"CONFIG":             174,
	"STATUS":             175,
	"WAIT":               177,
	"RECONFIGURE":        176,
	"REBALANCE":          179,
	"SYNC":               138,
	"GRANT":              188,
	"INDEX_CREATE":       75,
	"INDEX_DROP":         76,
	"INDEX_LIST":         77,
	"INDEX_STATUS":       139,
	"INDEX_WAIT":         140,
	"INDEX_RENAME":       156,
	"FUNCALL":            64,
	"BRANCH":             65,
	"OR":                 66,
	"AND":                67,
	"FOR_EACH":           68,
	"FUNC":               69,
	"ASC":                73,
	"DESC":               74,
	"INFO":               79,
	"MATCH":              97,
	"UPCASE":             141,
	"DOWNCASE":           142,
	"SAMPLE":             81,
	"DEFAULT":            92,
	"JSON":               98,
	"TO_JSON_STRING":     172,
	"ISO8601":            99,
	"TO_ISO8601":         100,
	"EPOCH_TIME":         101,
	"TO_EPOCH_TIME":      102,
	"NOW":                103,
	"IN_TIMEZONE":        104,
	"DURING":             105,
	"DATE":               106,
	"TIME_OF_DAY":        126,
	"TIMEZONE":           127,
	"YEAR":               128,
	"MONTH":              129,
	"DAY":                130,
	"DAY_OF_WEEK":        131,
	"DAY_OF_YEAR":        132,
	"HOURS":              133,
	"MINUTES":            134,
	"SECONDS":            135,
	"TIME":               136,
	"MONDAY":             107,
	"TUESDAY":            108,
	"WEDNESDAY":          109,
	"THURSDAY":           110,
	"FRIDAY":             111,
	"SATURDAY":           112,
	"SUNDAY":             113,
	"JANUARY":            114,
	"FEBRUARY":           115,
	"MARCH":              116,
	"APRIL":              117,
	"MAY":                118,
	"JUNE":               119,
	"JULY":               120,
	"AUGUST":             121,
	"SEPTEMBER":          122,
	"OCTOBER":            123,
	"NOVEMBER":           124,
	"DECEMBER":           125,
	"LITERAL":            137,
	"GROUP":              144,
	"SUM":                145,
	"AVG":                146,
	"MIN":                147,
	"MAX":                148,
	"SPLIT":              149,
	"UNGROUP":            150,
	"RANDOM":             151,
	"CHANGES":            152,
	"ARGS":               154,
	"BINARY":             155,
	"GEOJSON":            157,
	"TO_GEOJSON":         158,
	"POINT":              159,
	"LINE":               160,
	"POLYGON":            161,
	"DISTANCE":           162,
	"INTERSECTS":         163,
	"INCLUDES":           164,
	"CIRCLE":             165,
	"GET_INTERSECTING":   166,
	"FILL":               167,
	"GET_NEAREST":        168,
	"POLYGON_SUB":        171,
	"MINVAL":             180,
	"MAXVAL":             181,
}

func (x Term_TermType) Enum() *Term_TermType {
	p := new(Term_TermType)
	*p = x
	return p
}
func (x Term_TermType) String() string {
	return proto.EnumName(Term_TermType_name, int32(x))
}
func (x Term_TermType) MarshalJSON() ([]byte, error) {
	return json.Marshal(x.String())
}
func (x *Term_TermType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Term_TermType_value, data, "Term_TermType")
	if err != nil {
		return err
	}
	*x = Term_TermType(value)
	return nil
}

type VersionDummy struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *VersionDummy) Reset()         { *m = VersionDummy{} }
func (m *VersionDummy) String() string { return proto.CompactTextString(m) }
func (*VersionDummy) ProtoMessage()    {}

// You send one of:
// * A [START] query with a [Term] to evaluate and a unique-per-connection token.
// * A [CONTINUE] query with the same token as a [START] query that returned
//   [SUCCESS_PARTIAL] in its [Response].
// * A [STOP] query with the same token as a [START] query that you want to stop.
// * A [NOREPLY_WAIT] query with a unique per-connection token. The server answers
//   with a [WAIT_COMPLETE] [Response].
// * A [SERVER_INFO] query. The server answers with a [SERVER_INFO] [Response].
type Query struct {
	Type *Query_QueryType `protobuf:"varint,1,opt,name=type,enum=Query_QueryType" json:"type,omitempty"`
	// A [Term] is how we represent the operations we want a query to perform.
	Query *Term  `protobuf:"bytes,2,opt,name=query" json:"query,omitempty"`
	Token *int64 `protobuf:"varint,3,opt,name=token" json:"token,omitempty"`
	// This flag is ignored on the server.  `noreply` should be added
	// to `global_optargs` instead (the key "noreply" should map to
	// either true or false).
	OBSOLETENoreply *bool `protobuf:"varint,4,opt,name=OBSOLETE_noreply,def=0" json:"OBSOLETE_noreply,omitempty"`
	// If this is set to [true], then [Datum] values will sometimes be
	// of [DatumType] [R_JSON] (see below).  This can provide enormous
	// speedups in languages with poor protobuf libraries.
	AcceptsRJson     *bool              `protobuf:"varint,5,opt,name=accepts_r_json,def=0" json:"accepts_r_json,omitempty"`
	GlobalOptargs    []*Query_AssocPair `protobuf:"bytes,6,rep,name=global_optargs" json:"global_optargs,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}

const Default_Query_OBSOLETENoreply bool = false
const Default_Query_AcceptsRJson bool = false

func (m *Query) GetType() Query_QueryType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Query_START
}

func (m *Query) GetQuery() *Term {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *Query) GetToken() int64 {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return 0
}

func (m *Query) GetOBSOLETENoreply() bool {
	if m != nil && m.OBSOLETENoreply != nil {
		return *m.OBSOLETENoreply
	}
	return Default_Query_OBSOLETENoreply
}

func (m *Query) GetAcceptsRJson() bool {
	if m != nil && m.AcceptsRJson != nil {
		return *m.AcceptsRJson
	}
	return Default_Query_AcceptsRJson
}

func (m *Query) GetGlobalOptargs() []*Query_AssocPair {
	if m != nil {
		return m.GlobalOptargs
	}
	return nil
}

type Query_AssocPair struct {
	Key              *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val              *Term   `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Query_AssocPair) Reset()         { *m = Query_AssocPair{} }
func (m *Query_AssocPair) String() string { return proto.CompactTextString(m) }
func (*Query_AssocPair) ProtoMessage()    {}

func (m *Query_AssocPair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Query_AssocPair) GetVal() *Term {
	if m != nil {
		return m.Val
	}
	return nil
}

// A backtrace frame (see `backtrace` in Response below)
type Frame struct {
	Type             *Frame_FrameType `protobuf:"varint,1,opt,name=type,enum=Frame_FrameType" json:"type,omitempty"`
	Pos              *int64           `protobuf:"varint,2,opt,name=pos" json:"pos,omitempty"`
	Opt              *string          `protobuf:"bytes,3,opt,name=opt" json:"opt,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *Frame) Reset()         { *m = Frame{} }
func (m *Frame) String() string { return proto.CompactTextString(m) }
func (*Frame) ProtoMessage()    {}

func (m *Frame) GetType() Frame_FrameType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Frame_POS
}

func (m *Frame) GetPos() int64 {
	if m != nil && m.Pos != nil {
		return *m.Pos
	}
	return 0
}

func (m *Frame) GetOpt() string {
	if m != nil && m.Opt != nil {
		return *m.Opt
	}
	return ""
}

type Backtrace struct {
	Frames           []*Frame `protobuf:"bytes,1,rep,name=frames" json:"frames,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Backtrace) Reset()         { *m = Backtrace{} }
func (m *Backtrace) String() string { return proto.CompactTextString(m) }
func (*Backtrace) ProtoMessage()    {}

func (m *Backtrace) GetFrames() []*Frame {
	if m != nil {
		return m.Frames
	}
	return nil
}

// You get back a response with the same [token] as your query.
type Response struct {
	Type      *Response_ResponseType  `protobuf:"varint,1,opt,name=type,enum=Response_ResponseType" json:"type,omitempty"`
	ErrorType *Response_ErrorType     `protobuf:"varint,7,opt,name=error_type,enum=Response_ErrorType" json:"error_type,omitempty"`
	Notes     []Response_ResponseNote `protobuf:"varint,6,rep,name=notes,enum=Response_ResponseNote" json:"notes,omitempty"`
	Token     *int64                  `protobuf:"varint,2,opt,name=token" json:"token,omitempty"`
	// [response] contains 1 RQL datum if [type] is [SUCCESS_ATOM] or
	// [SERVER_INFO].  [response] contains many RQL data if [type] is
	// [SUCCESS_SEQUENCE] or [SUCCESS_PARTIAL].  [response] contains 1
	// error message (of type [R_STR]) in all other cases.
	Response []*Datum `protobuf:"bytes,3,rep,name=response" json:"response,omitempty"`
	// If [type] is [CLIENT_ERROR], [TYPE_ERROR], or [RUNTIME_ERROR], then a
	// backtrace will be provided.  The backtrace says where in the query the
	// error occurred.  Ideally this information will be presented to the user as
	// a pretty-printed version of their query with the erroneous section
	// underlined.  A backtrace is a series of 0 or more [Frame]s, each of which
	// specifies either the index of a positional argument or the name of an
	// optional argument.  (Those words will make more sense if you look at the
	// [Term] message below.)
	Backtrace *Backtrace `protobuf:"bytes,4,opt,name=backtrace" json:"backtrace,omitempty"`
	// If the [global_optargs] in the [Query] that this [Response] is a
	// response to contains a key "profile" which maps to a static value of
	// true then [profile] will contain a [Datum] which provides profiling
	// information about the execution of the query. This field should be
	// returned to the user along with the result that would normally be
	// returned (a datum or a cursor). In official drivers this is accomplished
	// by putting them inside of an object with "value" mapping to the return
	// value and "profile" mapping to the profile object.
	Profile          *Datum `protobuf:"bytes,5,opt,name=profile" json:"profile,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}

func (m *Response) GetType() Response_ResponseType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Response_SUCCESS_ATOM
}

func (m *Response) GetErrorType() Response_ErrorType {
	if m != nil && m.ErrorType != nil {
		return *m.ErrorType
	}
	return Response_INTERNAL
}

func (m *Response) GetNotes() []Response_ResponseNote {
	if m != nil {
		return m.Notes
	}
	return nil
}

func (m *Response) GetToken() int64 {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return 0
}

func (m *Response) GetResponse() []*Datum {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *Response) GetBacktrace() *Backtrace {
	if m != nil {
		return m.Backtrace
	}
	return nil
}

func (m *Response) GetProfile() *Datum {
	if m != nil {
		return m.Profile
	}
	return nil
}

// A [Datum] is a chunk of data that can be serialized to disk or returned to
// the user in a Response.  Currently we only support JSON types, but we may
// support other types in the future (e.g., a date type or an integer type).
type Datum struct {
	Type             *Datum_DatumType   `protobuf:"varint,1,opt,name=type,enum=Datum_DatumType" json:"type,omitempty"`
	RBool            *bool              `protobuf:"varint,2,opt,name=r_bool" json:"r_bool,omitempty"`
	RNum             *float64           `protobuf:"fixed64,3,opt,name=r_num" json:"r_num,omitempty"`
	RStr             *string            `protobuf:"bytes,4,opt,name=r_str" json:"r_str,omitempty"`
	RArray           []*Datum           `protobuf:"bytes,5,rep,name=r_array" json:"r_array,omitempty"`
	RObject          []*Datum_AssocPair `protobuf:"bytes,6,rep,name=r_object" json:"r_object,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *Datum) Reset()         { *m = Datum{} }
func (m *Datum) String() string { return proto.CompactTextString(m) }
func (*Datum) ProtoMessage()    {}

func (m *Datum) GetType() Datum_DatumType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Datum_R_NULL
}

func (m *Datum) GetRBool() bool {
	if m != nil && m.RBool != nil {
		return *m.RBool
	}
	return false
}

func (m *Datum) GetRNum() float64 {
	if m != nil && m.RNum != nil {
		return *m.RNum
	}
	return 0
}

func (m *Datum) GetRStr() string {
	if m != nil && m.RStr != nil {
		return *m.RStr
	}
	return ""
}

func (m *Datum) GetRArray() []*Datum {
	if m != nil {
		return m.RArray
	}
	return nil
}

func (m *Datum) GetRObject() []*Datum_AssocPair {
	if m != nil {
		return m.RObject
	}
	return nil
}

type Datum_AssocPair struct {
	Key              *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val              *Datum  `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Datum_AssocPair) Reset()         { *m = Datum_AssocPair{} }
func (m *Datum_AssocPair) String() string { return proto.CompactTextString(m) }
func (*Datum_AssocPair) ProtoMessage()    {}

func (m *Datum_AssocPair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Datum_AssocPair) GetVal() *Datum {
	if m != nil {
		return m.Val
	}
	return nil
}

// A [Term] is either a piece of data (see **Datum** above), or an operator and
// its operands.  If you have a [Datum], it's stored in the member [datum].  If
// you have an operator, its positional arguments are stored in [args] and its
// optional arguments are stored in [optargs].
//
// A note about type signatures:
// We use the following notation to denote types:
//   arg1_type, arg2_type, argrest_type... -> result_type
// So, for example, if we have a function `avg` that takes any number of
// arguments and averages them, we might write:
//   NUMBER... -> NUMBER
// Or if we had a function that took one number modulo another:
//   NUMBER, NUMBER -> NUMBER
// Or a function that takes a table and a primary key of any Datum type, then
// retrieves the entry with that primary key:
//   Table, DATUM -> OBJECT
// Some arguments must be provided as literal values (and not the results of sub
// terms).  These are marked with a `!`.
// Optional arguments are specified within curly braces as argname `:` value
// type (e.x `{noreply:BOOL}`)
// Many RQL operations are polymorphic. For these, alterantive type signatures
// are separated by `|`.
//
// The RQL type hierarchy is as follows:
//   Top
//     DATUM
//       NULL
//       BOOL
//       NUMBER
//       STRING
//       OBJECT
//         SingleSelection
//       ARRAY
//     Sequence
//       ARRAY
//       Stream
//         StreamSelection
//           Table
//     Database
//     Function
//     Ordering - used only by ORDER_BY
//     Pathspec -- an object, string, or array that specifies a path
//   Error
type Term struct {
	Type *Term_TermType `protobuf:"varint,1,opt,name=type,enum=Term_TermType" json:"type,omitempty"`
	// This is only used when type is DATUM.
	Datum            *Datum            `protobuf:"bytes,2,opt,name=datum" json:"datum,omitempty"`
	Args             []*Term           `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	Optargs          []*Term_AssocPair `protobuf:"bytes,4,rep,name=optargs" json:"optargs,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *Term) Reset()         { *m = Term{} }
func (m *Term) String() string { return proto.CompactTextString(m) }
func (*Term) ProtoMessage()    {}

func (m *Term) GetType() Term_TermType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Term_DATUM
}

func (m *Term) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *Term) GetArgs() []*Term {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Term) GetOptargs() []*Term_AssocPair {
	if m != nil {
		return m.Optargs
	}
	return nil
}

type Term_AssocPair struct {
	Key              *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Val              *Term   `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Term_AssocPair) Reset()         { *m = Term_AssocPair{} }
func (m *Term_AssocPair) String() string { return proto.CompactTextString(m) }
func (*Term_AssocPair) ProtoMessage()    {}

func (m *Term_AssocPair) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *Term_AssocPair) GetVal() *Term {
	if m != nil {
		return m.Val
	}
	return nil
}

func init() {
	proto.RegisterEnum("VersionDummy_Version", VersionDummy_Version_name, VersionDummy_Version_value)
	proto.RegisterEnum("VersionDummy_Protocol", VersionDummy_Protocol_name, VersionDummy_Protocol_value)
	proto.RegisterEnum("Query_QueryType", Query_QueryType_name, Query_QueryType_value)
	proto.RegisterEnum("Frame_FrameType", Frame_FrameType_name, Frame_FrameType_value)
	proto.RegisterEnum("Response_ResponseType", Response_ResponseType_name, Response_ResponseType_value)
	proto.RegisterEnum("Response_ErrorType", Response_ErrorType_name, Response_ErrorType_value)
	proto.RegisterEnum("Response_ResponseNote", Response_ResponseNote_name, Response_ResponseNote_value)
	proto.RegisterEnum("Datum_DatumType", Datum_DatumType_name, Datum_DatumType_value)
	proto.RegisterEnum("Term_TermType", Term_TermType_name, Term_TermType_value)
}
